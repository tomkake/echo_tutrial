package handlers

import (
	"net/http"
	"strings" // For error checking

	"apiserver/internal/domain"
	"apiserver/internal/generated/api" // oapi-codegen generated package
	"apiserver/internal/usecases"
	"github.com/labstack/echo/v4"
	openapi_types "github.com/oapi-codegen/runtime/types" // For openapi_types.UUID and openapi_types.Email
)

// UserHandler handles HTTP requests for user operations.
// It implements the api.ServerInterface generated by oapi-codegen.
type UserHandler struct {
	userInteractor usecases.UserInteractor
}

// NewUserHandler creates a new UserHandler.
// It returns api.ServerInterface to make it explicit, but the concrete type is *UserHandler.
func NewUserHandler(uc usecases.UserInteractor) api.ServerInterface {
	return &UserHandler{userInteractor: uc}
}

// --- Helper function to map domain.User to api.User (generated DTO) ---
// api.User only has Name as per openapi/components/schemas/users/user.yaml
func toAPIUser(domainUser *domain.User) api.User {
	if domainUser == nil {
		return api.User{} // Return empty struct if domainUser is nil
	}
	return api.User{
		Name: domainUser.Name,
	}
}

func toAPIUserSlice(domainUsers []domain.User) []api.User {
	apiUsers := make([]api.User, len(domainUsers))
	for i, du := range domainUsers {
		apiUsers[i] = toAPIUser(&du)
	}
	return apiUsers
}

// --- Implement methods from api.ServerInterface ---

// GetUsers (corresponds to operationId: getUsers)
// GET /v1/users
func (h *UserHandler) GetUsers(c echo.Context) error {
	users, err := h.userInteractor.GetAllUsers(c.Request().Context())
	if err != nil {
		// TODO: Implement proper error DTO mapping as per OpenAPI spec for errors
		return echo.NewHTTPError(http.StatusInternalServerError, "Failed to retrieve users: "+err.Error())
	}
	// Response is an array of api.User
	return c.JSON(http.StatusOK, toAPIUserSlice(users))
}

// PostUser (corresponds to operationId: post-user)
// POST /v1/user
func (h *UserHandler) PostUser(c echo.Context) error {
	var requestBody api.PostUserJSONRequestBody // This is api.UserInfo
	if err := c.Bind(&requestBody); err != nil {
		// TODO: Implement proper error DTO mapping
		return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body: "+err.Error())
	}

	// api.UserInfo (requestBody) has Name (string) and Email (openapi_types.Email).
	// Password is not part of UserInfo as per the OpenAPI spec.
	// This is a design flaw in the API spec if password creation is intended.
	// Using a placeholder password as discussed.
	placeholderPassword := "defaultSecurePassword123!" // Placeholder
	// In a real application, the API spec (UserInfo) should include a password field for creation.

	// Name and Email are directly available on requestBody.
	// openapi_types.Email is an alias for string, so it can be used directly.
	createdUser, err := h.userInteractor.CreateNewUser(c.Request().Context(), requestBody.Name, string(requestBody.Email), placeholderPassword)
	if err != nil {
		// TODO: Implement proper error DTO mapping
		return echo.NewHTTPError(http.StatusInternalServerError, "Failed to create user: "+err.Error())
	}

	// The spec for POST /v1/user response is an array of api.User. This is unconventional.
	// Returning a single created user for now, conforming to common practice.
	// If an array is strictly required: return c.JSON(http.StatusCreated, []api.User{toAPIUser(createdUser)})
	return c.JSON(http.StatusCreated, toAPIUser(createdUser))
}

// PathUser (corresponds to operationId: path-user)
// PATCH /v1/users/{user_id}
func (h *UserHandler) PathUser(c echo.Context, userId openapi_types.UUID) error {
	idStr := userId.String() // openapi_types.UUID is github.com/google/uuid.UUID

	// The oapi-codegen does not generate a specific request body type for PATCH in ServerInterface.
	// We assume it will be similar to UserInfo or a partial update.
	// Binding to api.UserInfo.
	var updateReq api.UserInfo
	if err := c.Bind(&updateReq); err != nil {
		// TODO: Implement proper error DTO mapping
		return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body for patch: "+err.Error())
	}

	// Prepare optional fields for interactor.
	// updateReq.Name is string, updateReq.Email is openapi_types.Email.
	var name, email *string
	var plainPassword *string // Password update is not supported by UserInfo DTO.

	// Only set fields if they appear to be provided in the request.
	// For JSON, if a field is missing, it will be its zero value (e.g., "" for string).
	// A more robust way would be to use pointer fields in UserInfo DTO for partial updates,
	// or check against zero values explicitly if that's the convention.
	// Given UserInfo fields are not pointers, we check for non-empty.
	if updateReq.Name != "" {
		name = &updateReq.Name
	}
	if updateReq.Email != "" {
		emailStr := string(updateReq.Email)
		email = &emailStr
	}
	// Password cannot be updated with the current UserInfo DTO.
	// If UserInfo had a *string Password field, it would be:
	// if updateReq.Password != nil { plainPassword = updateReq.Password }

	updatedUser, err := h.userInteractor.UpdateExistingUser(c.Request().Context(), idStr, name, email, plainPassword)
	if err != nil {
		if strings.Contains(strings.ToLower(err.Error()), "not found") { // Basic error check
			// TODO: Implement proper error DTO mapping
			return echo.NewHTTPError(http.StatusNotFound, "User not found")
		}
		// TODO: Implement proper error DTO mapping
		return echo.NewHTTPError(http.StatusInternalServerError, "Failed to update user: "+err.Error())
	}

	// Response for PATCH is a single api.User object
	return c.JSON(http.StatusOK, toAPIUser(updatedUser))
}

// DeleteUser (corresponds to operationId: delete-user)
// DELETE /v1/users/{user_id}
func (h *UserHandler) DeleteUser(c echo.Context, userId openapi_types.UUID) error {
	idStr := userId.String() // openapi_types.UUID is github.com/google/uuid.UUID

	err := h.userInteractor.RemoveUser(c.Request().Context(), idStr)
	if err != nil {
		if strings.Contains(strings.ToLower(err.Error()), "not found") { // Basic error check
			// TODO: Implement proper error DTO mapping
			return echo.NewHTTPError(http.StatusNotFound, "User not found")
		}
		// TODO: Implement proper error DTO mapping
		return echo.NewHTTPError(http.StatusInternalServerError, "Failed to delete user: "+err.Error())
	}
	// Response for DELETE is 200 OK with empty content as per spec.
	// Using http.StatusNoContent (204) is also common for DELETE success with no body.
	// The spec says 200 OK with "content: {}".
	return c.JSON(http.StatusOK, map[string]string{}) // Empty JSON object
}
